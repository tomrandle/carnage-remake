<!DOCTYPE html>
<html>
<head>
    <title>Carnage remake</title>

    <script src="http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.9.0.min.js"></script>

    <script src="keyStatus.js"></script>
    <script src="jquery.hotkeys.js"></script>
        <script src="libraries/sat/SAT.js"></script>


    <script>

        $(document).ready(function() {


            var aCoordinates = [[0,0],[0,0],[40,0],[40,4],[0,40]];
            var bCoordinates = [[0,0],[0,0],[40,0],[40,4],[0,40]];

            console.log(aCoordinates);

            collisionTest();
            function collisionTest() {

                var V = SAT.Vector;
                var P = SAT.Polygon;

                // Polygon A
                var polygon1 = new P(
                    new V(0,0), [
                        new V(0,0),
                        new V(40,0),
                        new V(40,40),
                        new V(0,40)
                    ]);

                // Polygon B
                var polygon2 = new P(
                    new V(30,0), [
                        new V(0,0),
                        new V(30, 0),
                        new V(0, 30)
                    ]);
                
                // Check collisisons

                var response = new SAT.Response();
                var collided = SAT.testPolygonPolygon(polygon1, polygon2, response);

                console.log(collided);


                // collided => true
                // response.overlap => 10
                // response.overlapN => (10, 0)


            }



            /* Variables */

            var FPS = 30;
            var g = 10;
            var timeInterval = 1 / FPS;
            var bullets = [];
            var players = [];

            var planeHeight = 20;
            var planeWidth = 40;

            /* Create canvas */

            var canvasWidth = $(window).width();
            var canvasHeight = $(window).height();

            var canvasElement = $("<canvas width='" + canvasWidth + "' height='" + canvasHeight + "'></canvas>");
            var canvas = canvasElement.get(0).getContext("2d");

            canvasElement.appendTo('body');


            /* Create players */ 

            players.push(new player(1,'#333', 'left', 'right','space'));
            players.push(new player(2,'#ff3300', 'q', 'w','e'));


            /* Each frame */
    
            function update() {

                /* TODO: Need this to run for each player */

                for (var i=0;i<players.length;i++) {
                    var player = players[i];
                    player.calculatePositions();
                    player.draw();
                    player.drawForceVectors();
                }

                for (var i=0;i<bullets.length;i++) {
                    console.log(bullets[i].draw());
                }
            }
            
            setInterval(function() {
                canvas.clearRect(0, 0, canvasWidth, canvasHeight);
                update();
            }, 1000/FPS);


            function bullet(owner, sourceX, sourceY, angle) {
                this.speed = 5;
                this.x = sourceX + planeWidth;
                this.bulletRadius = 4;
                this.y = canvasHeight - sourceY + planeHeight;
                this.angle = angle;
                this.position = 0;
                this.owner = owner;
                this.updateReadings = function() {
                    this.x = (Math.cos(this.angle) * this.speed) + this.x;
                    this.y = (Math.sin(-this.angle) * this.speed) + this.y;
                };

                this.draw = function() {
                    this.updateReadings();
                    canvas.beginPath();
                    canvas.arc(this.x,this.y, this.bulletRadius, 0, Math.PI*2, true); 
                    canvas.closePath();
                    canvas.fill();
                };
            };

            function player(id, color, rotateAnticlockwiseKey, rotateClockwiseKey, shootKey, startPosition) {
                this.id = id;
                this.color = color;
                this.rotateAnticlockwiseKey = rotateAnticlockwiseKey;
                this.rotateClockwiseKey = rotateClockwiseKey;
                this.shootKey = shootKey;
                this.ammo = 20;
                this.kills = 0;
                this.lives = 10;
                this.takeOffPosition = 1;
                this.x = 220;
                this.y = 270;
                this.angleOfAttack= 0;
                this.turnSpeed= Math.PI / 32;
                this.xSpeed=0;
                this.ySpeed=0;
                this.mass=100;
                this.weight= 0;
                this.terminalVelocity=50;
                this.dragCoefficient= 0.1;
                this.thrust= 600;

                this.fire = function() {
                    if (this.ammo > 1) {
                        this.ammo -= 1;
                        bullets.push (new bullet(this.id, this.x, this.y, this.angleOfAttack));
                    }
                };

                this.checkKeyboard = function() {

                    if (keydown[this.rotateAnticlockwiseKey]) {
                        this.angleOfAttack += this.turnSpeed;
                    }

                    if (keydown[this.rotateClockwiseKey]) {
                        this.angleOfAttack -= this.turnSpeed;
                    }

                    if (keydown[this.shootKey]) {
                        this.fire();
                    }

                    if (this.angleOfAttack >= (Math.PI))
                    {
                        this.angleOfAttack = this.angleOfAttack - (Math.PI * 2);
                    }

                    else {
                        if (this.angleOfAttack <= - Math.PI)
                        {
                            this.angleOfAttack = this.angleOfAttack + (2 * Math.PI);
                        }
                    }

                };




                this.calculateLift = function() {
                    
                    // var angle = this.calculateAngleOfMotion();

                    // var liftCoefficient = 0.1;


                    // if (Math.abs(angle) > Math.PI /2 ) {
                    //     liftCoefficient = 0;
                    // }

                   
                    // var lift = liftCoefficient * this.airspeed() * this.airspeed();
                    return (0);

                };

                this.calculateDrag = function() {

                    // To be realisitc the drag and lift coefficients need to change depending on the direction the plane is pointing. Drag needs to be much more agressive in the direction perpendicular to the bearing of the plane. 

                    var drag = this.dragCoefficient * this.airspeed() * this.airspeed();
                    return(drag);
                };

                this.calculateXAcceleration = function(){
                    // ((F-D)cosC + L sin C ) / m;

                    var thrustComponent = this.thrust *  Math.cos(this.angleOfAttack);
                    var dragComponent = this.calculateDrag() * Math.cos(this.calculateAngleOfMotion());
                    var liftComponent =this.calculateLift() * Math.sin(this.calculateAngleOfMotion());

                    $('#thrust-x-value').html(thrustComponent);
                    $('#drag-x-value').html(dragComponent);
                    $('#lift-x-value').html(liftComponent);


                    var a = (thrustComponent - dragComponent + liftComponent) / this.mass;
                    return(a);
                };

                this.calculateYAcceleration = function(){
                    // ((F-D)sinC + L cos C - W) / m;

                    var thrustComponent = this.thrust *  Math.sin(this.angleOfAttack);
                    var dragComponent = this.calculateDrag() * Math.sin(this.calculateAngleOfMotion());
                    var liftComponent = this.calculateLift() * Math.cos(this.calculateAngleOfMotion());


                    $('#thrust-y-value').html(thrustComponent);
                    $('#drag-y-value').html(dragComponent);
                    $('#lift-y-value').html(liftComponent);
                    var a = (thrustComponent - dragComponent + liftComponent - this.weight) /this.mass;
                    return(a);

                    
           
                };


                this.calculateSpeeds = function () {

                    var aX = this.calculateXAcceleration();
                    var aY = this.calculateYAcceleration();

                    /* v = u + at */

                    this.xSpeed = this.xSpeed + (aX * timeInterval);
                    this.ySpeed = this.ySpeed + (aY * timeInterval);

                };

                this.calculatePositions = function() {
                    this.checkKeyboard(); //make sure this only gets called once
                    this.calculateSpeeds();

                    /* Infinite canvas */

                    if (this.x > canvasWidth) {
                        this.x = 0;
                    }

                    if (this.x < 0) {
                        this.x = canvasWidth;
                    }


                    if (this.y > canvasHeight) {
                        this.y = 0;
                    }

                    if (this.y < 0) {
                        this.y = canvasHeight;
                    }

                    /* s = ut + 0.5 at^2*/
                    /*BODGE*/

                    this.x = this.x + (this.xSpeed * timeInterval);
                    this.y = this.y + (this.ySpeed * timeInterval);

                    };


       

                this.airspeed = function() {
                    var v = (Math.sqrt(Math.pow(this.xSpeed,2) + Math.pow(this.ySpeed,2)));
                    return(v);
                };

                this.calculateAngleOfMotion = function() {

                    var angle = Math.atan(this.ySpeed / this.xSpeed);
                        if (!angle) {
                        return(0);
                    }

                    if (this.xSpeed < 0 && this.ySpeed > 0)
                    {
                        angle = angle + Math.PI;

                    }

                    if (this.xSpeed < 0 && this.ySpeed < 0)
                    {
                        angle = angle - Math.PI;
                    }    
                
                    return (angle);

                };

                this.updateReadings = function() {
                    $('#bearing-value').html(this.angleOfAttack * 180 / Math.PI);
                    $('#angle-of-motion-value').html(this.calculateAngleOfMotion() * 180 / Math.PI);

                    $('#acceleration-x-value').html(this.calculateXAcceleration());
                    $('#acceleration-y-value').html(this.calculateYAcceleration());
                    $('#speed-x-value').html(this.xSpeed);
                    $('#speed-y-value').html(this.ySpeed);
                    $('#x-value').html(this.x);
                    $('#y-value').html(this.y);
                    $('#airspeed-value').html(this.airspeed());
                    $('#drag-value').html(this.calculateDrag());

                };

                this.draw = function() {
                    this.updateReadings();
                    canvas.save();
                    canvas.translate(this.x, (canvasHeight - this.y));
                    canvas.translate(planeWidth, planeHeight);
                    canvas.rotate(-this.angleOfAttack);
                    canvas.fillStyle = this.color;
                    canvas.fillRect((- planeWidth / 2), (- planeHeight / 2), planeWidth, planeHeight);
                    canvas.restore();


                    //Begin our drawing

                    var centerX = this.x + planeWidth;
                    var centerY = canvasHeight - this.y + planeHeight;

                    var internalAngle = Math.atan(planeHeight / planeWidth);
                    var internalLength = Math.sqrt((planeWidth * planeWidth) + (planeHeight * planeHeight)) * 0.5;
             
                    var pheta = this.angleOfAttack + internalAngle;
                    var alpha = this.angleOfAttack - internalAngle;

                    var topRightX = centerX + (internalLength * Math.cos(pheta));
                    var topRightY = centerY - (internalLength * Math.sin(pheta)) ;
                 
                    var bottomRightX = centerX + (internalLength * Math.cos(alpha));
                    var bottomRightY = centerY - (internalLength * Math.sin(alpha));

                    var bottomLeftX = centerX - (internalLength * Math.cos(-pheta));
                    var bottomLeftY = centerY - (internalLength * Math.sin(-pheta)) ;
                 
                    var topLeftX = centerX - (internalLength * Math.cos(-alpha));
                    var topLeftY = centerY - (internalLength * Math.sin(-alpha));





                    // canvas.beginPath();
                    // canvas.moveTo(topRightX, topRightY);

                    // canvas.lineTo(bottomRightX,bottomRightY);
                    // canvas.lineTo(bottomLeftX, bottomLeftY);
                    // canvas.lineTo(topLeftX,topLeftY);
                     
                    // //Define the style of the shape
                    // canvas.lineWidth = 1;
                    // canvas.fillStyle = "rgb(102, 204, 0)";
                    // canvas.strokeStyle = "rgb(0, 50, 200)";
                     
                    // //Close the path
                    // canvas.closePath(); 
                     
                    // //Fill the path with ourline and color
                    // canvas.fill();
                    // canvas.stroke();
                };


                this.drawForceVectors = function() {

                    var lineScale = 1;
                    var currentX = this.x + planeWidth;
                    var currentY = canvasHeight - this.y + planeHeight;


                    /* Weight */

                    var weightLineEndX = (this.weight * lineScale) + currentY;

                    canvas.beginPath();
                    canvas.moveTo(currentX, currentY);
                    canvas.lineTo(currentX,weightLineEndX);
                    canvas.stroke();

                    /* Lift */
                    
                    var liftLineEndX = (Math.sin(-this.angleOfAttack) * this.calculateLift() * lineScale) + currentX;
                    var liftLineEndY = -(Math.cos(-this.angleOfAttack) * this.calculateLift() * lineScale) + currentY;

                    canvas.beginPath();
                    canvas.moveTo(currentX, currentY);
                    canvas.lineTo(liftLineEndX,liftLineEndY);
                    canvas.stroke();

                    /* Thrust */
                    
                    var thrustLineEndX = (Math.cos(this.angleOfAttack) * this.thrust * lineScale) + currentX;
                    var thrustLineEndY = (Math.sin(-this.angleOfAttack) * this.thrust * lineScale) + currentY;

                    canvas.beginPath();
                    canvas.moveTo(currentX, currentY);
                    canvas.lineTo(thrustLineEndX,thrustLineEndY);
                    canvas.stroke();

                    /* Drag */

                    var drag = this.calculateDrag();
                    
                    var dragLineEndX = -(Math.cos(this.calculateAngleOfMotion()) * drag * lineScale) + currentX;
                    var dragLineEndY = (Math.sin(this.calculateAngleOfMotion()) * drag * lineScale) + currentY;


                    canvas.beginPath();
                    canvas.moveTo(currentX, currentY);
                    canvas.lineTo(dragLineEndX,dragLineEndY);
                    canvas.stroke();

                }
            };
        });

    </script>

    <style type="text/css">
        body {margin: 0; font-family:arial; font-size:11px;}
        canvas {background: lightblue;}
        table {position: fixed; right:10px; top:10px; width: 200px;}
    </style>

</head>

<body>
    <table id="data">
        <tr><td>Bearing</td><td id="bearing-value"></td></tr>
        <tr><td>Angle of motion</td><td id="angle-of-motion-value"></td></tr>

        <tr><td>X</td><td id="x-value"></td></tr>
        <tr><td>Y</td><td id="y-value"></td></tr>
        <tr><td>aX</td><td id="acceleration-x-value"></td></tr>
        <tr><td>aY</td><td id="acceleration-y-value"></td></tr>
        <tr><td>vX</td><td id="speed-x-value"></td></tr>
        <tr><td>vY</td><td id="speed-y-value"></td></tr>

        <tr><td>ThrustX</td><td id="thrust-x-value"></td></tr>
        <tr><td>ThrustY</td><td id="thrust-y-value"></td></tr>
        <tr><td>LiftX</td><td id="lift-x-value"></td></tr>
        <tr><td>LiftY</td><td id="lift-y-value"></td></tr>
        <tr><td>DragX</td><td id="drag-x-value"></td></tr>
        <tr><td>DragY</td><td id="drag-y-value"></td></tr>

        <tr><td>Speed</td><td id="airspeed-value"></td></tr>
        <tr><td>Drag</td><td id="drag-value"></td></tr>


    </table>
</body>

</html>